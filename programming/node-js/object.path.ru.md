## работа с String & Object

* очень часто для доступа в какую-то "зону" древообразной структуры используют формулу указывающую путь (напр CSS селекторы, XPath, путь в файловой системе, и т д)

* есть код (объектная структура данных)

  ```js
  
  let data = {
    
    users:[
      {
        name: "John",
        address: {
          city: "GoodTown",
          country: "Amazing States of Unity"
        }
      },
      {
        name: "Marry",
        address: {
          city: "JobTown",
          country: "Employment Emirates"
        }
      },
      
      // ...

    ]
    
  }
  
  ```
  представим себе что существует такой "протокол" который мы условно назовем "HAS" (Hierarchy Access Standard), суть которого сводится к тому что если, например нам надо получить из объекта структуры какое-то свойство ( даже то что запрятанно на 2-3+ уровня ниже в структуре ), то мы пишем строку типо "parent.child1.child2....".
Пример:
 - "users.0.name" - это путь до значения "John" в примере что выше
 - "users.1.address.city" - это путь до значения "JobTown" в примере что выше

 схема очень похожа на то как мы пишем адреса или пути в файловых системах, только там сегменты разделенны наклонными чертами
 
 * Представим себе такую функцию, алгоритм которой описан коротко внутри
  ```js
  function getValue( path ) {
    // 1. разбить путь через разделитель "."
    // 2. написать цикл который пробежиться по каждому сегменту пути
    // 3. когда закончится цикл - вы получете то свойство что вы искали (если оно есть)
  }
  ```
  она должна вернуть значение того свойства до которого указывает переданный путь в виде аргумента
  
 * ПОДСКАЗКА:
    ```js
    let path = "users.0.name"
    let segments = path... ???   // разбить строку -> ["users","0","name"]
    let step = data // установим шаг на самый верхний уровень структуры
        step = step[segments[0]] // спустится на один уровень в data - data["users"]
        step = step[segments[1]] // спустится на два уровеня в data - data["users"]["0"]
        ...                      // повторяем шаги до конца

    ```
 * ВНИМАНИЕ, для этого задания будем считать что данные по указанному путь ВСЕГДА присутствуют (т е - не будем проверять каждый шаг)   
  
