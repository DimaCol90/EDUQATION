## Строковый тип данных. Составные типы. Копирование текста


> Копирование данных из одного массива в другой делается путем итеративного назначение значений ячеек исходного массива, ячейкам массива копии

---

* У вас в наличие следующий фрагмент кода (строка представляющая источник)
    ```c
    char source[] = "Language";
    char destination[20]; 
    ```
    В этом коде были зарезервированы две строки памяти, одна из которых содержит информацию, а другая пустая, готовая для получения информации.

* Попробуйте ответить на вопрос - сколько ячеек в "source"?
* Попробуйте ответить на вопрос - сколько ячеек в "destination"?
* Если бы мы выводили **strlen(destination)** - какое значение получили бы на экране?

* Добавляем следующий код в продолжение вышесказанного
    ```c
    for(int i=0; i < strlen(source); i++){
        destination[i] = source[i];
    }

    printf("the original is \"%s\"", source);
    printf("the copy is     \"%s\"", destination);

    ```
    этот код копирует итеративно по одной ячейке исходника в массив предназначенный для копии (в ту же позицию)
    ниже это показано схематично

    ```
    index           0   1   2   3   4   5   6   7   8   9
    source[]       'L' 'a' 'n' 'g' 'u' 'a' 'g' 'e' '\0'
                    |   |   |   |   |   |   |   |
                    v   v   v   v   v   v   v   v      
                    v   v   v   v   v   v   v   v      
    destination[]  'L' 'a' 'n' 'g' 'u' 'a' 'g' 'e' '\0'
    ```
* Требуется изменить алгоритм так, чтобы источник копировался в место назначения со сдвигом на 1 ячейку вправо, другими словами как на следующей схеме
    ```
    index           0   1   2   3   4   5   6   7   8   9
    source[]       'L' 'a' 'n' 'g' 'u' 'a' 'g' 'e' '\0'
                    |   |   |   |   |   |   |   |
                     v   v   v   v   v   v   v   v      
                       v   v   v   v   v   v   v   v      
                        v   v   v   v   v   v   v   v      
    destination[]  ' ' 'L' 'a' 'n' 'g' 'u' 'a' 'g' 'e' '\0'
    ```

 БОНУС, допустим, есть переменная **offset**, которая получает положительное целочисленное значение. Напишите алгоритм, который копирует источник в массив "destination" смещая ячейки на  **offset** позиций вправо