## База данных с кошками

* Представим себе такую ситуацию: мы просим репозиторий найти по **id** какой-то объект, и репозиторий ищет его при помощи вот этого метода (алгоритма):
 
 ```java
  Object findById(Integer id){
     for(Object o: objects){
        if ( object.getId() == id ){
           return o;
        } 
        return null;
     }
  }

 ``` 
 сделаем пару выводов:
   1. Если объект не найден - картина ясна - возвращается **null**
   2. Если объект найден - мы возвращаем ссылку на объект, то есть при таком варианте поиска элементов "внешняя" по отношению к репозиторию логика получает ПРЯМОЙ доступ к объекту!
   3. То что происходит в пунтке 2 - нарушает целостность данных, так как "внешняя" логика сможет изменить "состояние" объекта напрямую через полученную ссылку - без вмешательства репозитория - например так:

     ```java
      Object o = Repository.getById(1);
      o.setSomething(newValue);
     ``` 
     и этого будет достаточно чтобы изменить объект. 
     
     Возникает вопрос - для чего тогда метод **save(object)** в рамках репозитория если мы обходимся без него?

ИСПОЛЬЗУЯ клонирование мы получаем два "состояния" одного и того же объекта (сущности), каждое из них соответствует своему контексту (в нашем случае: оригинал - в репозитории и клон - вне репозитория)

---

* Суть этого этапа, доделать логику методов поиска внутри репозитория таким образом чтобы они всегда возвращали КЛОН (копию) найденных объектов, а не ссылку на оригинал! Цель - иметь резервную копью объекта внутри репозитория, даже если переданный "вне" объект будет изменен, репозиторий будет удерживать оригинал до того момента пока мы не дадим добро на сохранение изменений!

* ДЛЯ этого:
  1. Ознакомьтесь с тем КАК клонировать объекты в Java при помощи унаследованного от **Object** метода **.clone()**   
  2. Добавьте в класс **Cat** метод **.clone()** который создаст точную реплику оригинального объекта (все свойства с такими-же значениями!) и проверьте его при помощи

     ```java

        Cat clonnedCat = originalCat.clone();

     ```
  3. Переделать все функции поиска репозитория так чтобы они возвращали КЛОНЫ оригиналов что хранятся на территории репозитория!
  4. Протестируйте переделанную логику так: найдите разными способами объекты из репозитория, измените какие-то их характеристики. Выведите после этого и сравните те же объекты вне и внутри репозитория