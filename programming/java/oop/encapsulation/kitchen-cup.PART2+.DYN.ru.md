## Принцип капсулы. Наследование. Переопределение

> часть 2 (пояснения)

* В момент когда СУПЕР КЛАСС (в вашем случае - Cup) запрещает доступ к определенному члену (в вашем случае - liquidVolume) применяя "private", единственный доступный путь наследника для взаимодействия с данным свойством - это какой-нибудь публичный метод (у вас - setLiquidVolume(...), gtLiquidVolume()). Проблема при поставленных условиях была в том что у вас СЕТТЕР наследника BigCup -> вызывая super().setLiquidVolume(...) проходил через логику защиты базового класса, где условия конфликтовали с условиями для "BigCup". 

!!! ВНИМАНИЕ - те что решили добавить заново свойство "liquidVolume" на уровне класса "BigCup" - создали копию этого свойства в памяти - т е - любой объект класса "BigCup" - содержал бы в себе 2 "liquidVolume": один скрытый на уровне "Cup" и другой в зоне доступа "BigCup" !!! 
Такой способ не приемлем так как он создает то что в разработке называют "ambiguity" (неопределенность!)

---

Самое правильное решение для пункта два - поменять модификатор доступа "liquidVolume" с "private" на "protected"!

---

требуется:
  1. Ответить на вопрос - чем отличается ограничения "private" и "protected"?
  2. Переделать код так чтобы BigCup и SmallCup - имели доступ к "liquidVolume"
